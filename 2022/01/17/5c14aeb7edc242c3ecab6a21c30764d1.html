<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>rspec-core概览</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="rspec-core概览" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="beego是一个MVC框架，与rails类似，其项目代码有一套推荐的目录结构，用户只需往里面填充代码即可实现路由、过滤、ORM等功能…" />
<meta property="og:description" content="beego是一个MVC框架，与rails类似，其项目代码有一套推荐的目录结构，用户只需往里面填充代码即可实现路由、过滤、ORM等功能…" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-17T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"beego是一个MVC框架，与rails类似，其项目代码有一套推荐的目录结构，用户只需往里面填充代码即可实现路由、过滤、ORM等功能…","@type":"BlogPosting","headline":"rspec-core概览","dateModified":"2022-01-17T00:00:00+00:00","url":"/2021/07/01/d4719e2ec0e7f6e099b645822bb66fd8.html","datePublished":"2022-01-17T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2021/07/01/d4719e2ec0e7f6e099b645822bb66fd8.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">some<strong>think</strong></a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags.html">标签</a><a class="page-link" href="/statistic.html">统计</a><a class="page-link" href="/about.html">关于</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">rspec-core概览</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-01-17T00:00:00+00:00" itemprop="datePublished">Jan 17, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div><span style='font-weight: bold;'>加载测试用例</span></div><div><br /></div><div>使用<code>bundle exec rspec</code>即可。在spec文件中加入<code>pp caller</code>，可得调用栈：</div><div><br /></div><pre><code>[".../2.7.2/lib/ruby/gems/2.7.0/gems/bootsnap-1.7.5/lib/bootsnap/load_path_cache/core_ext/kernel_require.rb:59:in `load'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/bootsnap-1.7.5/lib/bootsnap/load_path_cache/core_ext/kernel_require.rb:59:in `load'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/configuration.rb:2112:in `load_file_handling_errors'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/configuration.rb:1615:in `block in load_spec_files'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/configuration.rb:1613:in `each'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/configuration.rb:1613:in `load_spec_files'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/runner.rb:102:in `setup'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/runner.rb:86:in `run'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/runner.rb:71:in `run'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/runner.rb:45:in `invoke'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/exe/rspec:4:in `<top (required)>'",
 ".../2.7.2/bin/rspec:23:in `load'",
 ".../2.7.2/bin/rspec:23:in `<top (required)>'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/cli/exec.rb:63:in `load'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/cli/exec.rb:63:in `kernel_load'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/cli/exec.rb:28:in `run'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/cli.rb:476:in `exec'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/vendor/thor/lib/thor/command.rb:27:in `run'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/vendor/thor/lib/thor.rb:399:in `dispatch'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/cli.rb:30:in `dispatch'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/vendor/thor/lib/thor/base.rb:476:in `start'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/cli.rb:24:in `start'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/bundler-2.1.4/libexec/bundle:46:in `block in <top (required)>'",
 ".../2.7.2/lib/ruby/2.7.0/bundler/friendly_errors.rb:123:in `with_friendly_errors'",
 ".../2.7.2/lib/ruby/gems/2.7.0/gems/bundler-2.1.4/libexec/bundle:34:in `<top (required)>'",
 ".../2.7.2/bin/bundle:23:in `load'",
 ".../2.7.2/bin/bundle:23:in `<main>'"]
</code></pre><div><br /></div><div>源码如下，rspec会创建一个<code>Runner</code>对象，内含一个<code>RSpec::Core::Configuration</code>对象和<code>RSpec::Core::ConfigurationOptions</code>对象。如无意外，<code>@options.configure(@configuration)</code>会设置spec文件默认路径为项目的<code>spec/</code>目录，然后会用<code>load</code>方法加载它们</div><div><br /></div><pre><code># lib/rspec/core/runner.rb
module RSpec
  module Core
    class Runner
      def self.invoke
        disable_autorun!
        status = run(ARGV, $stderr, $stdout).to_i
        exit(status) if status != 0
      end

      def self.run(args, err=$stderr, out=$stdout)
        trap_interrupt
        options = ConfigurationOptions.new(args)

        if options.options[:runner]
          options.options[:runner].call(options, err, out)
        else
          new(options).run(err, out)
        end
      end

      def initialize(options, configuration=RSpec.configuration, world=RSpec.world)
        @options       = options
        @configuration = configuration
        @world         = world
      end

      def run(err, out)
        setup(err, out)
        return @configuration.reporter.exit_early(exit_code) if RSpec.world.wants_to_quit

        run_specs(@world.ordered_example_groups).tap do
          persist_example_statuses
        end
      end

      def setup(err, out)
        configure(err, out)
        return if RSpec.world.wants_to_quit

        @configuration.load_spec_files
      ensure
        @world.announce_filters
      end

      def configure(err, out)
        @configuration.error_stream = err
        @configuration.output_stream = out if @configuration.output_stream == $stdout
        @options.configure(@configuration)
      end
    end
  end
end
</code></pre><div><br /></div><div>简单来说，是这样的调用栈</div><div><br /></div><pre><code>exe/rspec
└─ RSpec::Core::Runner.invoke
    ├─ RSpec::Core::Runner#setup
    └─ RSpec::Core::Runner#run_specs
</code></pre><div><br /></div><div><span style='font-weight: bold;'>describe方法</span></div><div><br /></div><div>检查describe方法的定义，可见它是这样的</div><div><br /></div><pre><code>[1] pry(main)> $ RSpec.describe

From: .../2.7.2/lib/ruby/gems/2.7.0/gems/rspec-core-3.10.1/lib/rspec/core/dsl.rb:42:
Owner: #<Class:RSpec>
Visibility: public
Signature: describe(*args, &example_group_block)
Number of lines: 5

(class << RSpec; self; end).__send__(:define_method, name) do |*args, &example_group_block|
  group = RSpec::Core::ExampleGroup.__send__(name, *args, &example_group_block)
  RSpec.world.record(group)
  group
end
</code></pre><div><br /></div><div>也就是这里：</div><div><br /></div><pre><code># lib/rspec/core/dsl.rb
module RSpec
  module Core
    module DSL
      def self.expose_example_group_alias(name)
        return if example_group_aliases.include?(name)

        example_group_aliases << name

        (class << RSpec; self; end).__send__(:define_method, name) do |*args, &example_group_block|
          group = RSpec::Core::ExampleGroup.__send__(name, *args, &example_group_block)
          RSpec.world.record(group)
          group
        end

        expose_example_group_alias_globally(name) if exposed_globally?
      end
    end
  end
end
</code></pre><div><br /></div><div>搜寻expose<em>example</em>group_alias的用处，会发现这里</div><div><br /></div><pre><code># lib/rspec/core/example_group.rb
module RSpec
  module Core
    class ExampleGroup
      def self.define_example_group_method(name, metadata={})
        idempotently_define_singleton_method(name) do |*args, &example_group_block|
          thread_data = RSpec::Support.thread_local_data
          top_level   = self == ExampleGroup

          registration_collection =
            if top_level
              # ...

              thread_data[:in_example_group] = true
              RSpec.world.example_groups
            else
              children
            end

          begin
            description = args.shift
            combined_metadata = metadata.dup
            combined_metadata.merge!(args.pop) if args.last.is_a? Hash
            args << combined_metadata

            subclass(self, description, args, registration_collection, &example_group_block)
          ensure
            thread_data.delete(:in_example_group) if top_level
          end
        end

        RSpec::Core::DSL.expose_example_group_alias(name)
      end

      define_example_group_method :example_group
      define_example_group_method :describe
      define_example_group_method :context
      define_example_group_method :xdescribe, :skip => "Temporarily skipped with xdescribe"
      define_example_group_method :xcontext,  :skip => "Temporarily skipped with xcontext"
      define_example_group_method :fdescribe, :focus => true
      define_example_group_method :fcontext,  :focus => true

      def self.subclass(parent, description, args, registration_collection, &example_group_block)
        subclass = Class.new(parent)
        subclass.set_it_up(description, args, registration_collection, &example_group_block)
        subclass.module_exec(&example_group_block) if example_group_block
        MemoizedHelpers.define_helpers_on(subclass)
        subclass
      end
    end
  end
end
</code></pre><div><br /></div><div>这里的运作机制是：在rspec加载时，会加载<code>lib/rspec/core/example_group.rb</code>，这时会给<code>ExampleGroup</code>定义<code>example_group</code>、<code>describe</code>、<code>context</code>等单例方法，并且也给<code>RSpec</code>定义同样的单例方法，委派到<code>ExampleGroup</code>上</div><div><br /></div><div>于是，当你调用<code>RSpec.describe(..){..}</code>时，实际上它会调用<code>ExampleGroup.describe(..){..}</code>创建一个<code>ExampleGroup</code>的子类，然后在其中执行你提供的block</div><div><br /></div><div>新创建的<code>ExampleGroup</code>子类会被<code>const_set</code>到<code>ExampleGroups</code>上，常量名取自<code>describe</code>的第一个参数，如果<code>describe</code> 是递归调用，则<code>const_set</code>到父类上。如下：</div><div><br /></div><pre><code>module ExampleGroups
  extend Support::RecursiveConstMethods

  def self.assign_const(group)
    base_name   = base_name_for(group)
    const_scope = constant_scope_for(group)
    name        = disambiguate(base_name, const_scope)

    const_scope.const_set(name, group)
  end

  def self.constant_scope_for(group)
    const_scope = group.superclass
    const_scope = self if const_scope == ::RSpec::Core::ExampleGroup
    const_scope
  end
end
</code></pre><div><br /></div><div><span style='font-weight: bold;'>it方法</span></div><div><br /></div><div><code>describe</code>调用所带的block是在<code>ExampleGroup</code>子类上执行的，一般我们会在里面调用<code>it(..){..}</code>定义测试用例（当然，递归地调用<code>describe</code>、<code>context</code>等方法也是可以的），而<code>it</code>的定义也在<code>lib/rspec/core/example_group.rb</code> 里：</div><div><br /></div><pre><code># lib/rspec/core/example_group.rb
def self.define_example_method(name, extra_options={})
  idempotently_define_singleton_method(name) do |*all_args, &block|
    desc, *args = *all_args

    options = Metadata.build_hash_from(args)
    options.update(:skip => RSpec::Core::Pending::NOT_YET_IMPLEMENTED) unless block
    options.update(extra_options)

    RSpec::Core::Example.new(self, desc, options, block)
  end
end

define_example_method :example
define_example_method :it
define_example_method :specify
define_example_method :focus,    :focus => true
define_example_method :fexample, :focus => true
define_example_method :fit,      :focus => true
define_example_method :fspecify, :focus => true
define_example_method :xexample, :skip => 'Temporarily skipped with xexample'
define_example_method :xit,      :skip => 'Temporarily skipped with xit'
define_example_method :xspecify, :skip => 'Temporarily skipped with xspecify'
define_example_method :skip,     :skip => true
define_example_method :pending,  :pending => true
</code></pre><div><br /></div><div><code>it</code>方法所做的就是创建一个<code>Example</code>实例，然后加入到当前<code>ExampleGroup</code>类的<code>examples</code>数组中</div><div><br /></div><pre><code># lib/rspec/core/example.rb
def initialize(example_group_class, description, user_metadata, example_block=nil)
  # ...
  example_group_class.examples << self
  # ...
end
</code></pre><div><br /></div><div><span style='font-weight: bold;'>let方法</span></div><div><br /></div><div>此外，在spec文件的<code>describe</code>和<code>it</code>之间，我们还会使用<code>let</code>定义“运行时生成并且在用例内缓存”的变量，其源码如下</div><div><br /></div><pre><code># lib/rspec/core/example_group.rb
module RSpec
  module Core
    class ExampleGroup
      include MemoizedHelpers
      extend MemoizedHelpers::ClassMethods
    end
  end
end

# lib/rspec/core/memoized_helpers.rb
module RSpec
  module Core
    module MemoizedHelpers
      module ClassMethods
        def let(name, &block)
          # ...
          our_module = MemoizedHelpers.module_for(self)

          if our_module.instance_methods(false).include?(name)
            our_module.__send__(:remove_method, name)
          end
          our_module.__send__(:define_method, name, &block)

          if instance_methods(false).include?(name)
            remove_method(name)
          end

          if block.arity == 1
            define_method(name) { __memoized.fetch_or_store(name) { super(RSpec.current_example, &nil) } }
          else
            define_method(name) { __memoized.fetch_or_store(name) { super(&nil) } }
          end
        end
      end

      def self.module_for(example_group)
        get_constant_or_yield(example_group, :LetDefinitions) do
          mod = Module.new do
            include(Module.new {
              example_group.const_set(:NamedSubjectPreventSuper, self)
            })
          end

          example_group.const_set(:LetDefinitions, mod)
          mod
        end
      end

      def self.define_helpers_on(example_group)
         example_group.__send__(:include, module_for(example_group))
      end
    end
  end
end
</code></pre><div><br /></div><div>此处代码有点绕：首先，<code>let</code>方法会生成一个名为<code>:LetDefinitions</code>的模块，并将该模块<code>const_set</code>到当前<code>ExampleGroup</code>中（如果未生成过）。然后在该模块上以<code>let</code>调用的参数定义实例方法，并在当前<code>ExampleGroup</code>上以<code>let</code>调用的参数定义实例方法，但内部是<code>super</code>调用父类。最后，再将模块<code>include</code>到当前<code>ExampleGroup</code>上（见<code>define_helpers_on</code>）。</div><div><br /></div><div>如此一来，若在<code>describe</code>块中定义<code>let(:abc){ 123 }</code>，然后在<code>it</code>块中调用<code>abc</code>，因为<code>it</code>块是在<code>ExampleGroup</code>实例中执行，所以<code>abc</code>会被解析为<code>ExampleGroup</code>的实例方法，然后<code>super</code>到<code>LetDefinitions</code> 上。（在<code>super</code>外层会有缓存包装）</div><div><br /></div><div><span style='font-weight: bold;'>跳过测试</span></div><div><br /></div><div>如果想在定义<code>ExampleGroup</code>时声明跳过，可以使用<code>xdescribe</code>、<code>xcontext</code>，想在定义<code>Example</code>时声明跳过，可以使用<code>xit</code>、<code>xspecify</code>，它们会在<code>@metadata</code>中注入<code>:skip =&gt; &#39;Temporarily skipped with xxx&#39;</code>，</div><div><br /></div><pre><code># lib/rspec/core/example_group.rb
def self.set_it_up(description, args, registration_collection, &example_group_block)
  # ...
  @user_metadata = Metadata.build_hash_from(args)

  @metadata = Metadata::ExampleGroupHash.create(
    superclass_metadata, @user_metadata,
    superclass.method(:next_runnable_index_for),
    description, *args, &example_group_block
  )
  # ...
  config.apply_derived_metadata_to(@metadata)
  # ...
  config.configure_group(self)
end

# lib/rspec/core/example.rb
def initialize(example_group_class, description, user_metadata, example_block=nil)
  # ...
  @metadata = Metadata::ExampleHash.create(
    @example_group_class.metadata, user_metadata,
    example_group_class.method(:next_runnable_index_for),
    description, example_block
  )
  # ...
end
</code></pre><div><br /></div><div>然后在<code>Example</code>运行时，通过检查<code>skipped?</code>（读取<code>@metadata</code>）而跳过</div><div><br /></div><pre><code># lib/rspec/core/example.rb
def run(example_group_instance, reporter)
  # ...

  begin
    if skipped?
      Pending.mark_pending! self, skip
    elsif !RSpec.configuration.dry_run?
      with_around_and_singleton_context_hooks do
        begin
          run_before_example
          @example_group_instance.instance_exec(self, &@example_block)

          if pending?
            Pending.mark_fixed! self

            raise Pending::PendingExampleFixedError,
                  'Expected example to fail since it is pending, but it passed.',
                  [location]
          end
        rescue Pending::SkipDeclaredInExample => _

        rescue AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt => e
          set_exception(e)
        ensure
          run_after_example
        end
      end
    end
  rescue Support::AllExceptionsExceptOnesWeMustNotRescue => e
    set_exception(e)
  ensure
    @example_group_instance = nil # if you love something... let it go
  end

  # ...
end
</code></pre><div><br /></div><div>此外，从上面代码也可发现，如果运行中抛出<code>Pending::SkipDeclaredInExample</code>，也是会使测试用例跳过的，在用例中我们可以使用<code>skip</code>方法触发，它所属的<code>Pending</code>模块被<code>include</code>到<code>ExampleGroup</code>上，因而在<code>Example</code>执行<code>run</code>时，<code>@example_group_instance.instance_exec(self, &amp;@example_block)</code>可以访问到<code>skip</code>方法</div><div><br /></div><pre><code># lib/rspec/core/pending.rb
module RSpec
  module Core
    module Pending
      def skip(message=nil)
        current_example = RSpec.current_example
        Pending.mark_skipped!(current_example, message) if current_example
        raise SkipDeclaredInExample.new(message)
      end
    end
  end
end

# lib/rspec/core/example_group.rb
module RSpec
  module Core
    class ExampleGroup
      include Pending
    end
  end
end
</code></pre><div><br /></div><div><span style='font-weight: bold;'>shared<em>examples与include</em>examples</span></div><div><br /></div><div><code>shared_examples</code>声明可复用的用例，将block注册到<code>RSpec.world.shared_example_group_registry</code>，而<code>include_examples</code>则是声明复用，从<code>RSpec.world.shared_example_group_registry</code>找出指定的block，然后在当前<code>ExampleGroup</code>上<code>class_exec</code>。源码如下</div><div><br /></div><pre><code># lib/rspec/core/example_group.rb
def self.include_examples(name, *args, &block)
  find_and_eval_shared("examples", name, caller.first, *args, &block)
end

def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block)
  shared_module = RSpec.world.shared_example_group_registry.find(parent_groups, name)
  unless shared_module
    raise ArgumentError, "Could not find shared #{label} #{name.inspect}"
  end
  shared_module.include_in(
    self, Metadata.relative_path(inclusion_location),
    args, customization_block
  )
end

# lib/rspec/core/shared_example_group.rb
module RSpec
  module Core
    class SharedExampleGroupModule < Module
      attr_reader :definition

      def initialize(description, definition, metadata)
        @description = description
        @definition  = definition
        @metadata    = metadata
      end

      def include_in(klass, inclusion_line, args, customization_block)
        klass.update_inherited_metadata(@metadata) unless @metadata.empty?

        SharedExampleGroupInclusionStackFrame.with_frame(@description, inclusion_line) do
          RSpec::Support::WithKeywordsWhenNeeded.class_exec(klass, *args, &@definition)
          klass.class_exec(&customization_block) if customization_block
        end
      end
    end

    module SharedExampleGroup
      module TopLevelDSL
        def self.definitions
          proc do
            def shared_examples(name, *args, &block)
              RSpec.world.shared_example_group_registry.add(:main, name, *args, &block)
            end
            alias shared_context      shared_examples
            alias shared_examples_for shared_examples
          end
        end
      end

      class Registry
        def add(context, name, *metadata_args, &block)
          # ...

          ensure_block_has_source_location(block) { CallerFilter.first_non_rspec_line }
          warn_if_key_taken context, name, block

          metadata = Metadata.build_hash_from(metadata_args)
          shared_module = SharedExampleGroupModule.new(name, block, metadata)
          shared_example_groups[context][name] = shared_module
        end

        def find(lookup_contexts, name)
          lookup_contexts.each do |context|
            found = shared_example_groups[context][name]
            return found if found
          end

          shared_example_groups[:main][name]
        end
      end
    end
  end

  instance_exec(&Core::SharedExampleGroup::TopLevelDSL.definitions)
end
</code></pre><div><br /></div><div><span style='font-weight: bold;'>hooks</span></div><div><br /></div><div>在<code>describe</code>块中使用<code>before</code>、<code>after</code>、<code>around</code>可以注册回调，可以传参数<code>:example</code>（或<code>:each</code>）使回调在每个用例上运行，传<code>:context</code>（或<code>:all</code>）使回调在整个用例集上运行，其中<code>around</code>只可传于<code>:example</code>和<code>:each</code>。</div><div><br /></div><div>运作时机如下，从中亦可见，如果before回调报错，则同一范围的后续before回调以及用例不会执行，但after回调还是会执行</div><div><br /></div><pre><code># lib/rspec/core/runner.rb
def run_specs(example_groups)
  examples_count = @world.example_count(example_groups)
  examples_passed = @configuration.reporter.report(examples_count) do |reporter|
      # ...
      example_groups.map { |g| g.run(reporter) }.all?
    end
  end

  exit_code(examples_passed)
end


# lib/rspec/core/example_group.rb
def self.run(reporter=RSpec::Core::NullReporter)
  # ...

  begin
    run_before_context_hooks(new('before(:context) hook')) if should_run_context_hooks
    result_for_this_group = run_examples(reporter)
    # ...
  ensure
    run_after_context_hooks(new('after(:context) hook')) if should_run_context_hooks
  end
end

def self.run_examples(reporter)
  ordering_strategy.order(filtered_examples).map do |example|
    # ...
    succeeded = example.run(instance, reporter)
    # ...
  end.all?
end


# lib/rspec/core/example.rb
def run(example_group_instance, reporter)
  # ...
  with_around_and_singleton_context_hooks do
    begin
      run_before_example
      @example_group_instance.instance_exec(self, &@example_block)
      # ...
    ensure
      run_after_example
    end
  end
  # ...
end
</code></pre><div><br /></div>
  </div><a class="u-url" href="/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name"></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
