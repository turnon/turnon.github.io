<!doctype html> <html> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="chrome=1"> <title>Zp Yuan ActiveSupport Concern</title> <link href="/bundle-1857e13f.css" rel=stylesheet /> <meta name=viewport content="width=device-width"> <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> </head> <body> <div class=wrapper> <header> <ul> <li class=current><a href="/index.html"><strong>笔记</strong></a></li> <li><a href="/statistics.html"><strong>统计</strong></a></li> <li><a href="/about.html"><strong>关于</strong></a></li> </ul> <div class=tags> <ol> <li> <a class=post-tag href="/index.html?tag=ruby"> <span>ruby</span> <span>54</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rails"> <span>rails</span> <span>24</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=metaprogramming"> <span>metaprogramming</span> <span>11</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=versus"> <span>versus</span> <span>9</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=sinatra"> <span>sinatra</span> <span>7</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=test"> <span>test</span> <span>5</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rack"> <span>rack</span> <span>4</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=minitest"> <span>minitest</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=debug"> <span>debug</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=concurrency"> <span>concurrency</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=pattern"> <span>pattern</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=javascript"> <span>javascript</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jekyll"> <span>jekyll</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=middleman"> <span>middleman</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=functional"> <span>functional</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=tilt"> <span>tilt</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jquery"> <span>jquery</span> <span>1</span> </a> </li> </ol> </div> </header> <section> <article> <h1 class=post-title>ActiveSupport Concern</h1> <span class=post-date>2015-06-05</span> <a class=post-tag href="/index.html?tag=metaprogramming">metaprogramming</a> <a class=post-tag href="/index.html?tag=rails">rails</a> <a class=post-tag href="/index.html?tag=ruby">ruby</a> <div> <span><div><b id="简单来说"><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">简单来说</span></b></div> <div><br></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">两个目的：</span></div> <div><br></div> <div>1.同时增加实例方法和类方法</div> <div><br></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">2.链式增加类方法</span></div> <div><br></div> <div>首先，定义在module M中的类方法是无法通过include让class C/module N继承到的，因为module M的类方法其实是该module M的单例类的实例方法，而include只是让某个class C/module N的实例查找实例方法时能到被include的module M中查找，调用class C/module N类方法时，完全不会查找到module M的单例类。所以，你只能在M中定义实例方法，然后让C、N去extend M，这样来实现类方法的共享。</div> <div><br></div> <div>而如果还要共享实例方法，那你就需要再定义一个module L，然后让C去include，分两条语句，例如：</div> <div><br></div> <div class=ever-code><pre><code>class C
  extend ClassMethods
  include InstanceMethod
end</code></pre></div> <div><br></div> <div>想将ClassMethods与InstanceMethod合在一起（尤其是类方法和实例方法很相关的情况下），可使用<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ActiveSupport::Concer。</span>extend <span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ActiveSupport::Concern的module M，按照约定，内有module ClassMethods，以使include M的class C能将M::</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ClassMethods中的方法设为类方法，具体实现方法在</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">append_features中的else的</span>base.extend const_get(:ClassMethods)<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">。</span> </div> <div><br></div> <div>此外，还要解决一个问题：一般地，当N和M都内有<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">module ClassMethods，且N.include M时，是无法通过N找到M::</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ClassMethods的（重名了，只能找到N</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">::</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ClassMethods</span> <span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">），这就不可能在C.include N时获取M::ClassMethods。为此，需要以</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">append_features中的if的做法来保留对</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">M的指向，于</span>@_dependencies中<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">，然后，在</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">C.include N时，C逐个include </span>@_dependencies中的Concern，之后才extend N::ClassMethods</div> <div><br></div> <div>还有一些要注意的：</div> <div><br></div> <div>1.因M.extend <span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ActiveSupport::Concern，所以</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ActiveSupport::Concern中的</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">append_features和included不是用def self.xxxx来定义的，而是def xxx，这样才能通过extend使</span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">append_features和included成为M的类方法</span> </div> <div><br></div> <div>2.N.include M早于C.include N，才能使C获取<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">M::ClassMethods，因为链式增加类方法是即时extend </span><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">ClassMethods，而不是什么superclass查找链那种东西</span> </div> <div><br></div> <div><b id="源码">源码</b></div> <div><br></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">来自gems/activesupport-4.2.1/lib/active_support</span></div> <div><br></div> <div class=ever-code><pre><code>module ActiveSupport

  module Concern #通常用于M.extend ActiveSupport::Concern

    #...

    def self.extended(base)
      base.instance_variable_set(:@_dependencies, []) #若M.extend ActiveSupport::Concern，则有base=M，M.@_dependencies
    end

    def append_features(base) #被C.include调用时，即C.include M时，base=C，即M.append_features(C)
      if base.instance_variable_defined?(:@_dependencies) #如果C本身也是concern
        base.instance_variable_get(:@_dependencies) &lt;&lt; self #则不作实质的include，而只记录依赖关系
        return false
      else #如果C本身不是concern
        return false if base &lt; self #如果已经include过，则不再次include
        @_dependencies.each { |dep| base.send(:include, dep) } #永远都用base来include本concern曾“include”过的concern，
        super #include本concern
        base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods) #永远都用base，即C来extend本concern的ClassMethods
        base.class_eval(&amp;@_included_block) if instance_variable_defined?(:@_included_block) #在base，即C上class_eval回调block，见下面重写的included
      end
    end

    def included(base = nil, &amp;block) #若M.extend ActiveSupport::Concern，则有M的included（来自Module#included）被重写如下
      if base.nil?
        raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)

        @_included_block = block #以往的included回调方法要写很多base.，但现在改成注册回调block，然后base.class_eval，见上面append_features。实例见ActionController::Flash
      else
        super
      end
    end

    #...

end</code></pre></div> <div><br></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br></span></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><strong>图解</strong></span></div> <div><b id=""><br></b></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">如何递归地include和extend：</span></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><br></span></div> <div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><a href="/images/957d00/52d85e.gif" target=_blank><img src="/images/957d00/52d85e.gif" type="image/gif" height=1266 style="cursor: default; height: auto;" width=1134></a></span></div></span> </div> </article> </section> <footer> </footer> </div> <script src="/javascripts/bundle-853f63ec.js"></script> </body> </html>