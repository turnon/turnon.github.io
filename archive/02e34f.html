<!DOCTYPE html> <html> <head> <meta content="IE=edge" http-equiv=X-UA-Compatible> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name=viewport> <title>Zp Yuan 跟踪sinatra如何利用tilt进行render</title> <link href="/bundle-d18183fc.css" rel=stylesheet /> </head> <body> <nav> <ul> <li class="toc-button invisible"><a>目录</a></li> <li><a href="/index.html">笔记</a></li> <li><a href="http://whispering-fortress-75887.herokuapp.com/">统计</a></li> <li><a href="/about.html">关于</a></li> </ul> </nav> <aside> <div class=tags> <ul> <li> <a class=post-tag href="/index.html?tag=ruby"> <span>ruby</span> <span>42</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=metaprogramming"> <span>metaprogramming</span> <span>11</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rails"> <span>rails</span> <span>10</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=versus"> <span>versus</span> <span>9</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=javascript"> <span>javascript</span> <span>8</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=sinatra"> <span>sinatra</span> <span>7</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=pattern"> <span>pattern</span> <span>5</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rack"> <span>rack</span> <span>4</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=minitest"> <span>minitest</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=underscore"> <span>underscore</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=debug"> <span>debug</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=concurrency"> <span>concurrency</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jekyll"> <span>jekyll</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=test"> <span>test</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=middleman"> <span>middleman</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=functional"> <span>functional</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=tilt"> <span>tilt</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=java"> <span>java</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rubinius"> <span>rubinius</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jquery"> <span>jquery</span> <span>1</span> </a> </li> </ul> </div> </aside> <article> <h1 class=post-title>跟踪sinatra如何利用tilt进行render</h1> <span class=post-date>2017-02-22</span> <a class=post-tag href="/index.html?tag=pattern">pattern</a> <a class=post-tag href="/index.html?tag=ruby">ruby</a> <a class=post-tag href="/index.html?tag=tilt">tilt</a> <div> <span><div>完整trace在末尾</div> <div><br></div> <div>假设有sinatra script如下，有实例变量@a和局部变量b</div> <div><br></div> <div class=ever-code><pre><code>get '/' do
  @a = "Hello, world"
  erb(:index, {}, {b: 123})
end</code></pre></div> <div><br></div> <div><br></div> <div>模板index.erb为</div> <div><br></div> <div class=ever-code><pre><code>instance a: &lt;%= @a %&gt;
local b: &lt;%= b %&gt;</code></pre></div> <div><br></div> <div><br></div> <div>现跟踪该erb如何运作</div> <div><br></div> <div>sinatra中各种erb、erubis、haml、sass、scss，调用的都是render，render再用tilt来加载相应模板引擎来进行实际的render。于是用trace_tree来跟踪title的render方法</div> <div><br></div> <div class=ever-code><pre><code>def erb(template, options = {}, locals = {}, &amp;block)
  render(:erb, template, options, locals, &amp;block)
end

def render(engine, data, options = {}, locals = {}, &amp;block)
  locals          = options.delete(:locals) || locals         || {}
  scope           = options.delete(:scope)          || self
  # ...
  begin
    #...
    require 'trace_tree'
    output = binding.trace_tree(html: true, tmp: ['sinatra', 'render.html']) do
      template.render(scope, locals, &amp;block)
    end
  ensure
    @default_layout = layout_was
  end
  # ...
  output
end</code></pre></div> <div><br></div> <div><br></div> <div>粗略地看，render干的就是两件事：动态定义一个方法，然后执行它，这就返回了填充好的模板了</div> <div><br></div> <div class=ever-code><pre><code>def evaluate(scope, locals, &amp;block)
  locals_keys = locals.keys
  if SYMBOL_ARRAY_SORTABLE
    locals_keys.sort!
  else
    locals_keys.sort!{|x, y| x.to_s &lt;=&gt; y.to_s}
  end
  method = compiled_method(locals_keys)
  method.bind(scope).call(locals, &amp;block)
end</code></pre></div> <div><br></div> <div><br></div> <div>调用栈如下</div> <div><br></div> <div><a href="/images/02e34f/50e19f.png" target=_blank><img src="/images/02e34f/50e19f.png" type="image/png" style="height: auto;"></a></div> <div><br></div> <div><br></div> <div>compiled_method如下：动态定义方法，方法名含线程id以免重复，方法体是用字符串拼接（用lambda也可以，但这样就不像字符串那样好检查了），然后class_eval生成这个方法，再remove_method，以免污染，最后缓存在@compiled_method</div> <div><br></div> <div class=ever-code><pre><code>TOPOBJECT = Object.superclass || Object

def compiled_method(locals_keys)
  LOCK.synchronize do
    @compiled_method[locals_keys] ||= compile_template_method(locals_keys)
  end
end

def compile_template_method(local_keys)
  source, offset = precompiled(local_keys)
  local_code = local_extraction(local_keys)

  method_name = "__tilt_#{Thread.current.object_id.abs}"
  method_source = String.new

  if method_source.respond_to?(:force_encoding)
    method_source.force_encoding(source.encoding)
  end

  method_source &lt;&lt; &lt;&lt;-RUBY
    TOPOBJECT.class_eval do
      def #{method_name}(locals)
        Thread.current[:tilt_vars] = [self, locals]
        class &lt;&lt; self
          this, locals = Thread.current[:tilt_vars]
          this.instance_eval do
            #{local_code}
  RUBY
  offset += method_source.count("\n")
  method_source &lt;&lt; source
  method_source &lt;&lt; "\nend;end;end;end"
  Object.class_eval(method_source, eval_file, line - offset)
  unbind_compiled_method(method_name)
end

def unbind_compiled_method(method_name)
  method = TOPOBJECT.instance_method(method_name)
  TOPOBJECT.class_eval { remove_method(method_name) }
  method
end</code></pre></div> <div><br></div> <div><br></div> <div>加入puts来检查method_source，可见模板如下（去掉头尾的TOPOBJECT.class_eval和end才是真正的方法定义）</div> <div><br></div> <div class=ever-code><pre><code>        TOPOBJECT.class_eval do
          def __tilt_12082330(locals)
            Thread.current[:tilt_vars] = [self, locals]
            class &lt;&lt; self
              this, locals = Thread.current[:tilt_vars]
              this.instance_eval do
                b = locals[:b]
        begin
          __original_outvar = @_out_buf if defined?(@_out_buf)

@_out_buf = _buf = String.new
 @_out_buf &lt;&lt; 'instance a: '; @_out_buf &lt;&lt; ( @a ).to_s; @_out_buf &lt;&lt; '
'; @_out_buf &lt;&lt; 'local b: '; @_out_buf &lt;&lt; ( b ).to_s; @_out_buf &lt;&lt; '
';
@_out_buf

        ensure
          @_out_buf = __original_outvar
        end

end;end;end;end</code></pre></div> <div><br></div> <div><br></div> <div>中间的@_out_buf那段来自于precompiled</div> <div><br></div> <div><a href="/images/02e34f/de83bd.png" target=_blank><img src="/images/02e34f/de83bd.png" type="image/png" style="height: auto;"></a></div> <div><br></div> <div><br></div> <div>precompiled的实现是一种template pattern，所有XXXTemplate都继承自Template，并重写precompiled（其实也有些是直接重写evaluate的，例如AsciidoctorTemplate，反正Template#render调用的是Template#evaluate，只要接口统一为evaluate就可以，也算是种adapter pattern吧）</div> <div><br></div> <div class=ever-code><pre><code>module Tilt
  class ERBTemplate &lt; Template
    #...
    if RUBY_VERSION &gt;= '1.9.0'
      def precompiled(locals)
        source, offset = super
        [source, offset + 1]
      end
    end
  end
end</code></pre></div> <div><br></div> <div><br></div> <div>Template的precompiled会将重写过的precompiled_preamble，precompiled_template，precompiled_postamble拼在一起</div> <div><br></div> <div class=ever-code><pre><code>def precompiled(local_keys)
  preamble = precompiled_preamble(local_keys)
  template = precompiled_template(local_keys)
  postamble = precompiled_postamble(local_keys)
  source = String.new
  #...
  source &lt;&lt; preamble &lt;&lt; "\n" &lt;&lt; template &lt;&lt; "\n" &lt;&lt; postamble
  [source, preamble.count("\n")+1]
end</code></pre></div> <div><br></div> <div><br></div> <div>其中precompiled_template就是模板的生成。例如，ERBTemplate就是这样重写precompiled_template的</div> <div><br></div> <div class=ever-code><pre><code>module Tilt
  class ERBTemplate &lt; Template
    #...

    def prepare
      #...
      @engine = ::ERB.new(data, options[:safe], options[:trim], @outvar)
    end

    def precompiled_template(locals)
      source = @engine.src
      source
    end</code></pre></div> <div><br></div> <div><br></div> <div>演示一下平常地使用erb（不过tilt默认用erubis所以刚刚才生成的@_out_buf......不同）</div> <div><br></div> <div class=ever-code><pre><code>irb(main):010:0&gt; puts ERB.new('a: &lt;%= @a %&gt;').src
#coding:UTF-8
_erbout = ''; _erbout.concat "a: "; _erbout.concat(( @a ).to_s); _erbout.force_encoding(__ENCODING__)
=&gt; nil</code></pre></div> <div><br></div> <div><br></div> <div>串联起来，为了能获取实例变量，模板函数要绑定在传入的scope（原Sinatra::Base用dup复制出的self）上执行</div> <div><br></div> <div class=ever-code><pre><code>method.bind(scope).call(locals, &amp;block)</code></pre></div> <div><br></div> <div><br></div> <div>而局部变量，如上所示，作为方法参数传入，而方法体早已用local_extraction写死，得出诸如b = locals[:b]的语句</div> <div><br></div> <div class=ever-code><pre><code>def local_extraction(local_keys)
  local_keys.map do |k|
    if k.to_s =~ /\A[a-z_][a-zA-Z_0-9]*\z/
      "#{k} = locals[#{k.inspect}]"
    else
      raise "invalid locals key: #{k.inspect} (keys must be variable names)"
    end
  end.join("\n")
end</code></pre></div> <div><br></div> <div><br></div> <div>至此，模板填充完毕。</div> <div><br></div> <div>完整trace如下</div> <div><br></div> <div> <a href="/images/02e34f/2ef450.html" target=_blank><img src="/images/02e34f/1e2126.png" alt="20170222_render.html"></a><br> </div></span> </div> </article> <script src="/javascripts/bundle-d6f5bf21.js"></script> </body> </html>