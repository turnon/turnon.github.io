<!doctype html> <html> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="chrome=1"> <title>Zp Yuan iterator/enumerator pattern</title> <link href="/bundle-c1bc5672.css" rel=stylesheet /> <meta name=viewport content="width=device-width"> <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> </head> <body> <div class=wrapper> <header> <ul> <li><a href="/index.html"><strong>笔记</strong></a></li> <li><a href="/statistics.html"><strong>统计</strong></a></li> <li><a href="/about.html"><strong>关于</strong></a></li> </ul> <div class=tags> <ol> <li> <a class=post-tag href="/index.html?tag=ruby"> <span>ruby</span> <span>46</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rails"> <span>rails</span> <span>14</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=metaprogramming"> <span>metaprogramming</span> <span>11</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=versus"> <span>versus</span> <span>10</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=javascript"> <span>javascript</span> <span>8</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=sinatra"> <span>sinatra</span> <span>7</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=pattern"> <span>pattern</span> <span>6</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rack"> <span>rack</span> <span>4</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=minitest"> <span>minitest</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=underscore"> <span>underscore</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=debug"> <span>debug</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=concurrency"> <span>concurrency</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jekyll"> <span>jekyll</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=test"> <span>test</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=middleman"> <span>middleman</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=functional"> <span>functional</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=tilt"> <span>tilt</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=java"> <span>java</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rubinius"> <span>rubinius</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jquery"> <span>jquery</span> <span>1</span> </a> </li> <li></li> </ol> </div> </header> <section> <article> <h1 class=post-title>iterator/enumerator pattern</h1> <span class=post-date>2013-12-15</span> <a class=post-tag href="/index.html?tag=java">java</a> <a class=post-tag href="/index.html?tag=javascript">javascript</a> <a class=post-tag href="/index.html?tag=pattern">pattern</a> <a class=post-tag href="/index.html?tag=rubinius">rubinius</a> <a class=post-tag href="/index.html?tag=ruby">ruby</a> <a class=post-tag href="/index.html?tag=versus">versus</a> <div> <span><div><b id="分为external和internal">分为external和internal</b></div> <div><br></div> <div>external，生成一个迭代器或叫枚举器，由客户端驱动，可同时迭代多个iterator，并可控制各个的迭代速度 （例如，可用于merge），可传递。缺点是多出一个iterator对象得知原集合的游标，破坏了封装性</div> <div>internal，将针对每个元素的操作传给可迭代的集合 ，不需管理next，hasNext。但不能同时进行多个集合的迭代</div> <div>external的remove方法应能保证安全（不要导致迭代到最后时越界了）和有效（不要跳过了被删元素的后一个元素）</div> <div><br></div> <div><b id="外部迭代器的删除方法的实现要点">外部迭代器的删除方法的实现要点</b></div> <div><br></div> <div>检查modCount（add会使外部modCount++，与内部modCount不符，因为add动作会使已new出来的迭代器不能完整表示当前整个表，所以要报ConcurrentModificationException）</div> <div>检查okToRemove（remove是remove刚刚被抛出node，所以每次remove前一步必须是next，以提供对node的检查，next使okToRemove为true，remove使okToRemove为false）</div> <div>再调用外部类的remove（current.prev），外部类的remove使外部modCount++，最后内部modCount++，使okToRemove为false</div> <div><br></div> <div><b id="java external">java external</b></div> <div><br></div> <div>jdk只提供external，如下。若想实现internal，需写个类来封装“针对每个元素的操作”</div> <div><br></div> <div>实现Iterable&lt;E&gt;接口的类，需实现Iterator&lt;E&gt; iterator()方法。</div> <div>实现Iterator&lt;E&gt;接口的类，需实现E next() ，boolean hasNext() ，remove()方法。是迭代器的类，能迭代。</div> <div><br></div> <div>for(Iterator&lt;E&gt; it = c.iterator(); it.hasNext(); ) { E e = it.next(); // 对o的操作... } 或者 for(E e : c)</div> <div>Iterable只是包装了Iterator,从而允许实现此接口的对象成为foreach语句的目标，而且这样的话，更方便以后的扩展。JDK中的集合类，比如List一族或者Set一族</div> <div>当编译器见到一个正用于Iterable的对象的增强for循环的时候，他用对iterator方法的那些调用代替增强for循环一得到一个Iterator对象，然后调用next和hasNext</div> <div><br></div> <div>可迭代的类，能返回迭代器。该类本身不维护遍历集合的指针，一切内部状态由迭代器维护</div> <div><br></div> <div>为什么一定要去实现Iterable这个接口呢？为什么不直接实现Iterator接口呢？因为Iterator接口的核心方法next()或者hasNext()是依赖于迭代器的当前迭代位置的。如果Collection直接实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。但即时这样，Collection也只能同时存在一个当前迭代位置。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。多个迭代器是互不干扰的。</div> <div><br></div> <div> <b id="ruby ">ruby </b><b id=external>external</b> </div> <div><br></div> <div>用index变量来维护：</div> <div><br></div> <div class=ever-code><pre><code>class ArrayIterator
  def initialize(array)
    @array = array
    @index = 0
  end

  def has_next?
    @index &lt; @array.length
  end

  def item
    @array[@index]
  end

  def next_item
    value = @array[@index]
    @index += 1
    value
  end
end</code></pre></div> <div><br></div> <div><br></div> <div>用Fiber来维护，如下是经简化的rubinius的Enumerator：</div> <div><br></div> <div class=ever-code><pre><code>module Enumerable
  class Enumerator

    # 即使生成的迭代器是默认执行:each
    # 也可通过include Enumerable来获得map、reduce等能力
    include Enumerable

    def each(*args)
      enumerator = self

      # 如有提供更多参数，则拼接到原参数后
      # 并set为enumerator实例变量，使each_with_block获取到
      new_args = @args

      unless args.empty?
        enumerator = dup
        new_args = @args.empty? ? args : (@args + args)
      end

      enumerator.args = new_args

      # 如有block，则运行block，否则仍然返回迭代器
      if block_given?
        enumerator.each_with_block do |*yield_args|
          yield(*yield_args)
        end
      else
        enumerator
      end
    end

    # 对原始enumerable实行each/map等操作
    def each_with_block
      @object.__send__ @iter, *@args do |*args|
        yield(*args)
      end
    end

    def next
      # @lookahead是个数组，用于支持peek操作
      # 不能单纯用一个变量来赋值，并在next时重设为nil
      # 因为peek出的可能为nil，这就无法检查该nil是来自enumerable还是enumerator设置的了
      return @lookahead.shift unless @lookahead.empty?

      @generator ||= Iterator.new self

      # @generator.next?一开始时必回返回true
      # 若enumerable为空集合，each中的yield将不会执行
      # 这回导致@done设为true，抛出StopIteration
      # 但Iterator的报错信息为iteration has ended
      # 而Enumerator却想报iteration reached end
      # 所以才rescue。不然直接next，也不用next?，也是可以的
      begin
        return @generator.next if @generator.next?
      rescue StopIteration
      end

      exception = StopIteration.new "iteration reached end"
      Rubinius.privately do
        exception.result = @generator.result
      end

      raise exception
    end

    class Iterator

      attr_reader :result

      def initialize(obj)
        @object = obj
        rewind
      end

      def next?
        !@done
      end

      # 通过each Fiber.yield来逐个返回
      # enumerable只需能响应each即可，enumeratot无需关心其内部指针
      # 当each完了，@done就被设为true，fiber以此种方式告知不能再next
      def next
        reset unless @fiber
        val = @fiber.resume
        raise StopIteration, "iteration has ended" if @done
        return val
      end

      def rewind
        @fiber = nil
        @done = false
      end

      def reset
        @done = false
        @fiber = Fiber.new do
          obj = @object
          @result = obj.each { |*val| Fiber.yield *val }
          @done = true
        end
      end
    end

end</code></pre></div> <div><br></div> <div><br></div> <div>lazy/infinite的迭代器</div> <div><br></div> <div>设计要点：</div> <div>1.为能够实现链式操作，每次链式调用都应返回同类对象，该对象具备链式调用接口</div> <div>2.下一节点对象逐次拉取上一节点对象的迭代方法，然后对返回值进行过滤或转换</div> <div>3.下一节点对象不应修改上一节点的迭代状态（each做法），或至少不应修改源节点（next做法）</div> <div><br></div> <div>一种简单实现：</div> <div><br></div> <div class=ever-code><pre><code>require 'fiber'

class MyEnum
  class Lazy

    def initialize &amp;enum
      @level = 0
      @enum = enum
    end

    attr_accessor :level
    private :level=

    # 用于链式拼接一些筛选器，select等等
    def chain &amp;enum
      Lazy.new(&amp;enum).tap do |lazy|
        lazy.send :level=, self.level.succ
      end
    end

    # 为保证调用next时不修改源头
    # 所以第二个环节须复制源头的迭代器
    # 第二个以后的链还是会修改第二个的迭代状态
    # 此种实现无法将某段链保留下来，再新增不同的尾段
    # 每次都要从头链
    def self_or_root
      level == 0 ? Lazy.new(&amp;@enum) : self
    end

    def next
      rewind unless @fiber
      @fiber.resume
    end

    def next?
      rewind unless @fiber
      @fiber.alive?
    end

    # 因为此take的实现会在n次循环后返回n，所以需pop掉最后一个
    def to_a
      [].tap do |arr|
        arr &lt;&lt; self.next while next?
        arr.pop
      end
    end

    def take n
      source = self_or_root
      chain do |yielder|
        n.times do
          yielder.yield source.next
        end
      end
    end

    def select &amp;block
      source = self_or_root
      chain do |yielder|
        loop do
          fetched = source.next
          until block.call fetched
            fetched = source.next
          end
          yielder.yield fetched
        end
      end
    end

    def map &amp;block
      source = self_or_root
      chain do |yielder|
        loop do
          yielder.yield block.call source.next
        end
      end
    end

    def rewind
      @fiber = wrap_loop
    end

    def wrap_loop
      Fiber.new do
        @enum.call Yielder.new
      end
    end
  end

  class Yielder
    def yield to_return
      Fiber.yield to_return
    end
  end

end</code></pre></div> <div><br></div> <div><br></div> <div><b id=ruby_internal>ruby internal</b></div> <div><br></div> <div><br></div> <div class=ever-code><pre><code>a = [10, 20, 30]
a.each {|element| puts("The element is #{element}")}</code></pre></div> <div><br></div> <div><br></div> <div>enumerable</div> <div><br></div> <div>inlcude Enumerable，并实现集合的each和元素的&lt;=&gt;</div> <div>获得include? all? any? min max……</div> <div><br></div> <div>现实：</div> <div><br></div> <div>String.scan each each_byte</div> <div>Hash.each_key each_value</div> <div>File.each</div> <div>Pathname.each</div> <div><br></div> <div> <b id="js ">js </b><b id=internal>internal</b> </div> <div><br></div> <div>一般都是internal</div> <div><br></div> <div>Array.prototype.forEach</div> <div>$.each</div> <div>_.each</div> <div><br></div> <div><br></div></span> </div> </article> </section> <footer> </footer> </div> <script src="/javascripts/bundle-dad8ae3e.js"></script> </body> </html>