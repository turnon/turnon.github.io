<!doctype html> <html> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="chrome=1"> <title>Zp Yuan activerecord inlcudes</title> <link href="/bundle-c1bc5672.css" rel=stylesheet /> <meta name=viewport content="width=device-width"> <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> </head> <body> <div class=wrapper> <header> <ul> <li><a href="/index.html"><strong>笔记</strong></a></li> <li><a href="/statistics.html"><strong>统计</strong></a></li> <li><a href="/about.html"><strong>关于</strong></a></li> </ul> <div class=tags> <ol> <li> <a class=post-tag href="/index.html?tag=ruby"> <span>ruby</span> <span>46</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rails"> <span>rails</span> <span>14</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=metaprogramming"> <span>metaprogramming</span> <span>11</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=versus"> <span>versus</span> <span>10</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=javascript"> <span>javascript</span> <span>8</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=sinatra"> <span>sinatra</span> <span>7</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=pattern"> <span>pattern</span> <span>6</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rack"> <span>rack</span> <span>4</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=minitest"> <span>minitest</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=underscore"> <span>underscore</span> <span>3</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=debug"> <span>debug</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=concurrency"> <span>concurrency</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jekyll"> <span>jekyll</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=test"> <span>test</span> <span>2</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=middleman"> <span>middleman</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=functional"> <span>functional</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=tilt"> <span>tilt</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=java"> <span>java</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=rubinius"> <span>rubinius</span> <span>1</span> </a> </li> <li> <a class=post-tag href="/index.html?tag=jquery"> <span>jquery</span> <span>1</span> </a> </li> <li></li> </ol> </div> </header> <section> <article> <h1 class=post-title>activerecord inlcudes</h1> <span class=post-date>2017-03-28</span> <a class=post-tag href="/index.html?tag=rails">rails</a> <a class=post-tag href="/index.html?tag=ruby">ruby</a> <div> <span><div>直观上来看，includes就是执行两条sql，第二条以第一条的ids作为参数，以使关联记录在第二条sql中一次过查出，避免1+N问题</div> <div><br></div> <div>跟踪看看：</div> <div><br></div> <div class=ever-code><pre><code>irb(main):034:0&gt; binding.trace_tree(html: true, tmp: ['rails', 'includes.html']){Article.includes(:comments).limit(2).each{}}
  Article Load (2752.8ms)  SELECT  "articles".* FROM "articles" LIMIT ?  [["LIMIT", 2]]
  Comment Load (7870.3ms)  SELECT "comments".* FROM "comments" WHERE "comments"."article_id" IN (2, 3)
=&gt; [#&lt;Article id: 2, title: "Brandy of the Damned", text: "To Say Nothing of the Dog", created_at: "2017-03-28 06:23:20", updated_at: "2017-03-28 06:23:20", user_id: 6&gt;, #&lt;Article id: 3, title: "A Farewell to Arms", text: "Vile Bodies", created_at: "2017-03-28 06:23:20", updated_at: "2017-03-28 06:23:20", user_id: 2&gt;]</code></pre></div> <div><br></div> <div><br></div> <div>调用栈如下</div> <div><br></div> <div> <a href="/images/4d0a1d/01c7ed.html" target=_blank><img src="/images/4d0a1d/89fc36.png" alt="includes.html"></a><br> </div> <div><br></div> <div>include就是将要include的association先暂存于includes_values</div> <div><br></div> <div class=ever-code><pre><code>def includes(*args)
  check_if_method_has_arguments!(:includes, args)
  spawn.includes!(*args)
end

def includes!(*args) # :nodoc:
  args.reject!(&amp;:blank?)
  args.flatten!

  self.includes_values |= args
  self
end</code></pre></div> <div><br></div> <div><br></div> <div>当执行each实际查询时，执行路径如下，可见eager_loading?为false</div> <div><br></div> <div><a href="/images/4d0a1d/50e19f.png" target=_blank><img src="/images/4d0a1d/50e19f.png" type="image/png" style="height: auto;"></a></div> <div><br></div> <div><br></div> <div>从源码来看，eager_loading?是用于决定join不join的</div> <div><br></div> <div class=ever-code><pre><code>def exec_queries(&amp;block)
  @records = eager_loading? ? find_with_associations.freeze : @klass.find_by_sql(arel, bound_attributes, &amp;block).freeze

  preload = preload_values
  preload +=  includes_values unless eager_loading?
  preloader = build_preloader
  preload.each do |associations|
    preloader.preload @records, associations
  end

  @records.each(&amp;:readonly!) if readonly_value

  @loaded = true
  @records
end</code></pre></div> <div><br></div> <div><br></div> <div>那么eager_loading?具体是什么呢，步进看看，发现由四组values（一堆表名）是否有值来决定</div> <div><br></div> <div class=ever-code><pre><code>From: /home/z/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activerecord-5.0.2/lib/active_record/relation.rb @ line 640 ActiveRecord::Relation#eager_loading?:

    637: def eager_loading?
    638:   @should_eager_load ||=
    639:     eager_load_values.any? ||
 =&gt; 640:     includes_values.any? &amp;&amp; (joined_includes_values.any? || references_eager_loaded_tables?)
    641: end

[1] pry(#&lt;Article::ActiveRecord_Relation&gt;)&gt; eager_load_values
=&gt; []
[2] pry(#&lt;Article::ActiveRecord_Relation&gt;)&gt; includes_values
=&gt; [:comments]
[3] pry(#&lt;Article::ActiveRecord_Relation&gt;)&gt; joined_includes_values
=&gt; []
[4] pry(#&lt;Article::ActiveRecord_Relation&gt;)&gt; references_eager_loaded_tables?
=&gt; false</code></pre></div> <div><br></div> <div><br></div> <div>搜索整个activerecord，得知eager_load_values是这样设置的（暂时未明为什么不直接写left_outer_join）</div> <div><br></div> <div class=ever-code><pre><code># Forces eager loading by performing a LEFT OUTER JOIN on +args+:
#
#   User.eager_load(:posts)
#   # SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
#   # FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
#   # "users"."id"
def eager_load(*args)
  check_if_method_has_arguments!(:eager_load, args)
  spawn.eager_load!(*args)
end

def eager_load!(*args) # :nodoc:
  self.eager_load_values += args
  self
end</code></pre></div> <div><br></div> <div><br></div> <div>而joined_includes_values是这样的，就是若发现includes中含有joins的表，也进行eager load（即导致exec_queries走find_with_associations ）</div> <div><br></div> <div class=ever-code><pre><code># Joins that are also marked for preloading. In which case we should just eager load them.
# Note that this is a naive implementation because we could have strings and symbols which
# represent the same association, but that aren't matched by this. Also, we could have
# nested hashes which partially match, e.g. { a: :b } &amp; { a: [:b, :c] }
def joined_includes_values
  includes_values &amp; joins_values
end</code></pre></div> <div><br></div> <div><br></div> <div>references_eager_loaded_tables?骤看涉及到arel比较复杂，只看最后一行的话，只关注references_values和joined_tables</div> <div><br></div> <div class=ever-code><pre><code>From: /home/z/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activerecord-5.0.2/lib/active_record/relation.rb @ line 736 ActiveRecord::Relation#references_eager_loaded_tables?:

    722: def references_eager_loaded_tables?
    723:   joined_tables = arel.join_sources.map do |join|
    724:     if join.is_a?(Arel::Nodes::StringJoin)
    725:       tables_in_string(join.left)
    726:     else
    727:       [join.left.table_name, join.left.table_alias]
    728:     end
    729:   end
    730:
    731:   joined_tables += [table.name, table.table_alias]
    732:
    733:   # always convert table names to downcase as in Oracle quoted table names are in uppercase
    734:   joined_tables = joined_tables.flatten.compact.map(&amp;:downcase).uniq
    735:
 =&gt; 736:   (references_values - joined_tables).any?
    737: end

[9] pry(#&lt;Article::ActiveRecord_Relation&gt;)&gt; joined_tables
=&gt; ["articles"]
[10] pry(#&lt;Article::ActiveRecord_Relation&gt;)&gt; references_values
=&gt; []</code></pre></div> <div><br></div> <div><br></div> <div>references_values的设置如下</div> <div><br></div> <div class=ever-code><pre><code># Use to indicate that the given +table_names+ are referenced by an SQL string,
# and should therefore be JOINed in any query rather than loaded separately.
# This method only works in conjunction with #includes.
# See #includes for more details.
#
#   User.includes(:posts).where("posts.name = 'foo'")
#   # Doesn't JOIN the posts table, resulting in an error.
#
#   User.includes(:posts).where("posts.name = 'foo'").references(:posts)
#   # Query now knows the string references posts, so adds a JOIN
def references(*table_names)
  check_if_method_has_arguments!(:references, table_names)
  spawn.references!(*table_names)
end

def references!(*table_names) # :nodoc:
  table_names.flatten!
  table_names.map!(&amp;:to_s)

  self.references_values |= table_names
  self
end</code></pre></div> <div><br></div> <div><br></div> <div>结合rails guide来看，references是用来指定sql片段中的表名的，效果等同includes...where加hash参数，总之，会造成join，也需要eager load返回true来导致exec_queries走find_with_associations（rails guide建议includes...where写成joins会更直观）</div> <div><br></div> <div>而单单includes的话，想要的效果就是执行两条sql，第二条以第一条的ids作为参数，并把返回的记录归类到第一条的model上，但保持第一条sql的记录数而不inner join</div> <div><br></div> <div>粗略地看，在调用栈中没看到有调ids方法，不过有owner_keys</div> <div><br></div> <div class=ever-code><pre><code>From: /home/z/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/activerecord-5.0.2/lib/active_record/associations/preloader/association.rb @ line 75 ActiveRecord::Associations::Preloader::Association#associated_records_by_owner:

    64: def associated_records_by_owner(preloader)
    65:   records = load_records do |record|
    66:     owner = owners_by_key[convert_key(record[association_key_name])]
    67:     association = owner.association(reflection.name)
    68:     association.set_inverse_instance(record)
    69:   end
    70:
    71:   owners.each_with_object({}) do |owner, result|
    72:     result[owner] = records[convert_key(owner[owner_key_name])] || []
    73:   end
    74:   binding.pry
 =&gt; 75: end

[2] pry(#&lt;ActiveRecord::Associations::Preloader::HasMany&gt;)&gt; owners
=&gt; [#&lt;Article:0x007fb7c31efe60 id: 81, title: "The Daffodil Sky", text: "Beyond the Mexique Bay", created_at: Mon, 27 Mar 2017 15:57:57 UTC +00:00, updated_at: Mon, 27 Mar 2017 15:57:57 UTC +00:00, user_id: 38&gt;,
 #&lt;Article:0x007fb7c31dfdf8 id: 82, title: "This Side of Paradise", text: "Edna O'Brien", created_at: Mon, 27 Mar 2017 15:57:57 UTC +00:00, updated_at: Mon, 27 Mar 2017 15:57:57 UTC +00:00, user_id: 39&gt;]
[3] pry(#&lt;ActiveRecord::Associations::Preloader::HasMany&gt;)&gt; owner_keys
=&gt; [81, 82]</code></pre></div> <div><br></div> <div><br></div> <div>preloader执行第二条sql的过程大概如下</div> <div><br></div> <div><a href="/images/4d0a1d/de83bd.png" target=_blank><img src="/images/4d0a1d/de83bd.png" type="image/png" style="height: auto;"></a></div></span> </div> </article> </section> <footer> </footer> </div> <script src="/javascripts/bundle-dad8ae3e.js"></script> </body> </html>